package edu.usc.ict.iago.agent;

import java.util.HashMap;
import java.util.LinkedList;

import edu.usc.ict.iago.agent.EventHelper.Expression;
import edu.usc.ict.iago.utils.Event;
import edu.usc.ict.iago.utils.Event.EventClass;
import edu.usc.ict.iago.utils.Event.SubClass;
import edu.usc.ict.iago.utils.GameSpec;
import edu.usc.ict.iago.utils.Offer;
import edu.usc.ict.iago.utils.Preference;
import edu.usc.ict.iago.utils.Preference.Relation;

public class Lying<State> extends BusinessLogic {
	
	private IAGOCoreVH agentCore;
	private AgentUtilsExtension utils;
	private GameSpec game;
	private TestBehavior behavior;
	public static boolean agentOwsAFavor = false;
	private StateEventController<State> stateEventController; // Just here to let us use the StateEvent functions (can't be static because functions are generic)
	public State currState = State.ASKFAVORITE;
	private Offer stateStartSuggestedOffer = null;
//	public boolean didEnterLying = false;
	
	enum State {
		 ASKFAVORITE,
		 MAKEDEAL1,
	 	 END
	 }
	
	@Override
	public void reset() {
		super.reset();
		stateStartSuggestedOffer = null;
		currState = State.ASKFAVORITE;
	}
	

	public Lying(AgentUtilsExtension utils, IAGOCoreVH agentCore, GameSpec game, TestBehavior behavior) {
		this.utils = utils;
		this.agentCore = agentCore;
		this.game = game;
		this.behavior = behavior;
		reset();
		this.stateEventController = new StateEventController<Lying.State>();
		stateEventController.massMachineStates(State.ASKFAVORITE, State.MAKEDEAL1, Event.EventClass.SEND_MESSAGE, Event.SubClass.PREF_INFO, State.class);
		
		stateEventController.massMachineStates(State.MAKEDEAL1, State.END, Event.EventClass.SEND_MESSAGE, Event.SubClass.OFFER_ACCEPT, State.class);
		stateEventController.massMachineStates(State.MAKEDEAL1, State.END, Event.EventClass.SEND_MESSAGE, Event.SubClass.OFFER_REJECT, State.class);
		stateEventController.massMachineStates(State.MAKEDEAL1, State.END, Event.EventClass.SEND_OFFER, null, State.class);

	}
	
	/**
	 * Checks if the sent event is accepted in the current state. 
	 * Used to determine if we need to switch to a new algorithm
	 * @param e: The Event to be checked.
	 * @return True if the state machine accepts the event, false otherwise
	 */
	public boolean doesAcceptEvent(Event e) {
		boolean acceptEvent = stateEventController.doesAcceptEvent(e, currState); 
		// State controller does not support preference type so need to make a special check
		if (e.getPreference() != null) {
			System.out.println("Lying doesAcceptEvent() event contains preference, acceptEvent = " + acceptEvent + ", isQuery = " + e.getPreference().isQuery());
			acceptEvent &= !e.getPreference().isQuery();
		}
		return acceptEvent;
	}
	
	/**
	 * Starting point of the algorithm
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	public LinkedList<Event> start(Event e){
//		System.out.println("StackDivide start()");
		StateEvent<State> stateEvent = new StateEvent<State>(currState, e.getType(), e.getSubClass());
		State newState = stateEventController.getState(stateEvent);
		System.out.println("StackDivide curr BL = " + blState);
		if (blState == BLState.START) {
			System.out.println("StackDivide first");
			blState = BLState.ONGOING;
			LinkedList<Event> returnedEvents = funcByState(e);
			return returnedEvents;
		}
		
		if (newState != null) {
//			System.out.println("Changing states: " + currState + " -> " + newState);
			currState = newState;
			LinkedList<Event> returnedEvents = funcByState(e);
			return returnedEvents;
		}
		return null;
	}
	
	/**
	 * Switch case over the state we are currently in. 
	 * There is probably a much better way to do this
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	private LinkedList<Event> funcByState(Event e) {
		LinkedList<Event> resp = null;
		switch (currState)
		{
			case ASKFAVORITE:
				resp = stateAskFavorite(e);
				break;
			case MAKEDEAL1:	
				resp = stateMakeDeal1(e);
				break;
			case END:
				resp = stateEnd(e);
				break;

		}
		return resp;

	}
	
	private LinkedList<Event> stateAskFavorite(Event event){
		System.out.println("StackDivide ask pref");
		LinkedList<Event> resp = new LinkedList<Event>();
		Event askPref = EventHelper.message("I would like to divide the free resources as fairly as possible,"
				+ " can you please tell me what is your favorite resource?");
				
		resp.add(askPref);
		return resp;
	}
	
	
	//Started an offer
	private LinkedList<Event> stateMakeDeal1(Event event){
		LinkedList<Event> resp = new LinkedList<Event>();
		Preference pref = event.getPreference();
		
		if (pref != null && !pref.isQuery()) {
			utils.addPref(pref);
			utils.reconcileContradictionsAll();
			
			if (pref.getRelation() == Relation.BEST) {				
				if (PreferenceHelper.missingInfo(pref)) {
					resp.add(EventHelper.message("What exactly is your favorite item?"));
				} else {
					resp.add(EventHelper.expression(Expression.SAD));
					resp.add(EventHelper.message("Oh snap, it seems we both want the same thing"));
					resp.add(EventHelper.message("..."));
					resp.add(EventHelper.expression(Expression.NEUTRAL));
					resp.add(EventHelper.message("What do you think about this deal?"));
					currState = State.MAKEDEAL1;
					resp.addAll(makeDeal(event));
				}
			} else {
				resp.add(EventHelper.message("Sorry, It's a bit hard to tell what your favorite item is."));
				if (PreferenceHelper.missingInfo(pref)) {
					resp.add(EventHelper.message("Can you please give some usable info?"));
				} else {
					resp.add(EventHelper.message("Can you please give some more info?"));
				}
			}
		}
		return resp;
	}	
	
	
	
	//Started an offer
	private LinkedList<Event> makeDeal(Event event){
		LinkedList<Event> resp = new LinkedList<Event>();
		Offer offer = new Offer(game.getNumIssues());
		int[][] offerMat = utils.offerToMatrix(offer);
		int temp = game.getNumIssues();
		for (int i=0; i<temp; i++) {
			offerMat[utils.freeRow][i] = game.getIssueQuants()[i];
		}
		offer = utils.matrixToOffer(offerMat);
		int agentFave = this.utils.getAgentFavoriteFreeResourceInOffer(offer);
		int playerFave = this.utils.getPlayerFavoriteFreeResourceInOffer(offer);
		if(event.getSubClass().equals(Event.SubClass.OFFER_REJECT)) {
			
			resp.add(EventHelper.expression(Expression.SAD));
			resp.add(EventHelper.message("I can sweeten the deal a bit, just for you <3"));
			resp.add(EventHelper.expression(Expression.HAPPY));
			
			// Moving 1.5 stacks of favorite items in exchange of 1 stack of players favorite item
			offerMat[utils.myRow][agentFave] = offerMat[utils.freeRow][agentFave];
			offerMat[utils.freeRow][agentFave] = 0;
			agentFave = this.utils.getAgentFavoriteFreeResourceInOffer(offer);
			int numOfItems = offerMat[utils.myRow][0];
			int halfItems = (int) Math.ceil(numOfItems/2);
			offerMat[utils.myRow][agentFave] = halfItems;
			offerMat[utils.freeRow][agentFave] = numOfItems - halfItems;
			offerMat[utils.adversaryRow][playerFave] = offerMat[utils.freeRow][playerFave];
			offerMat[utils.freeRow][playerFave] = 0; 

		} else {
			
			offerMat[utils.myRow][agentFave] = offerMat[utils.freeRow][agentFave];
			offerMat[utils.freeRow][agentFave] = 0;
			agentFave = this.utils.getAgentFavoriteFreeResourceInOffer(utils.matrixToOffer(offerMat));
			offerMat[utils.myRow][agentFave] = offerMat[utils.freeRow][agentFave];
			offerMat[utils.freeRow][agentFave] = 0;
			offerMat[utils.adversaryRow][playerFave] = offerMat[utils.freeRow][playerFave];
			offerMat[utils.freeRow][playerFave] = 0; 
		}
		resp.add(EventHelper.message("I think this is a good offer"));
		Offer stackOffer = utils.matrixToOffer(offerMat);
		resp.add(EventHelper.offer(stackOffer));
		return resp;
	}
	
	private LinkedList<Event> stateEnd(Event e){
//		System.out.println("StackDivide stateEnd()");
		LinkedList<Event> resp = new LinkedList<Event>();
		
		// Stack divide offer was rejected by the player
		if (e.getSubClass() == Event.SubClass.OFFER_REJECT) {
			
			resp.add(EventHelper.expression(Expression.SAD));
			resp.add(EventHelper.message("Aww"));

			this.blState = BLState.FAILURE;
			
		// Stack divide offer was accepted by the player
		} else if (e.getSubClass() == Event.SubClass.OFFER_ACCEPT){	
			
			resp.add(EventHelper.expression(Expression.HAPPY));
			resp.add(EventHelper.message("Yay"));

			behavior.allocated = stateStartSuggestedOffer;
			this.blState = BLState.SUCCESS;

		// Stack divide offer was interrupted by the player by making a new offer
		} else {
			resp.add(EventHelper.expression(Expression.ANGRY));
			resp.add(EventHelper.message("How rude!"));

			continueFlow=true; // Tell the main flow that we want for it to continue handling the event (probably with default bl)
			this.blState = BLState.FAILURE;

		}
		return resp;
	}

}
