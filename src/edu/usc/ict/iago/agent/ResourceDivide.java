package edu.usc.ict.iago.agent;

import java.util.ArrayList;
import java.util.LinkedList;

import edu.usc.ict.iago.agent.BusinessLogic.BLState;
import edu.usc.ict.iago.agent.StackDivide.State;
import edu.usc.ict.iago.utils.Event;
import edu.usc.ict.iago.utils.GameSpec;
import edu.usc.ict.iago.utils.Offer;

public class ResourceDivide<State> extends BusinessLogic {
	private IAGOCoreVH agentCore;
	private AgentUtilsExtension utils;
	private GameSpec game;
	private TestBehavior behavior;
	public static boolean agentOwsAFavor = false;
	private StateEventController<State> stateEventController; // Just here to let us use the StateEvent functions (can't be static because functions are generic)
	public State currState = State.ASKFAVORITE;
	private Offer stateStartSuggestedOffer = null;
	
	enum State {
		 ASKFAVORITE,
		 MAKEDEAL,
	 	 END
	 }
	
	// Enum for deciding which negotiaotor will get a favor
	enum FavorState{
		PLAYER,
		AGENT
	}
	
	@Override
	public void reset() {
		super.reset();
		stateStartSuggestedOffer = null;
		currState = State.ASKFAVORITE;
	}
	
	public ResourceDivide(AgentUtilsExtension utils, IAGOCoreVH agentCore, GameSpec game, TestBehavior behavior) {
		this.utils = utils;
		this.agentCore = agentCore;
		this.game = game;
		this.behavior = behavior;
		reset();
		this.stateEventController = new StateEventController<ResourceDivide.State>();
		stateEventController.massMachineStates(State.ASKFAVORITE, State.MAKEDEAL, Event.EventClass.SEND_MESSAGE, Event.SubClass.PREF_INFO, State.class);
		stateEventController.massMachineStates(State.MAKEDEAL, State.END, Event.EventClass.SEND_MESSAGE, Event.SubClass.OFFER_ACCEPT, State.class);
		stateEventController.massMachineStates(State.MAKEDEAL, State.END, Event.EventClass.SEND_MESSAGE, Event.SubClass.OFFER_REJECT, State.class);
		stateEventController.massMachineStates(State.MAKEDEAL, State.END, Event.EventClass.SEND_OFFER, null, State.class);

	}
	
	/**
	 * Checks if the sent event is accepted in the current state. 
	 * Used to determine if we need to switch to a new algorithm
	 * @param e: The Event to be checked.
	 * @return True if the state machine accepts the event, false otherwise
	 */
	public boolean doesAcceptEvent(Event e) {
		boolean acceptEvent = stateEventController.doesAcceptEvent(e, currState); 
		// State controller does not support preference type so need to make a special check
		if (e.getPreference() != null) {
			System.out.println("StackDivide doesAcceptEvent() event contains preference, acceptEvent = " + acceptEvent + ", isQuery = " + e.getPreference().isQuery());
			acceptEvent &= !e.getPreference().isQuery();
		}
		return acceptEvent;
	}
	
	/**
	 * Starting point of the algorithm
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	public LinkedList<Event> start(Event e){
//		System.out.println("StackDivide start()");
		StateEvent<State> stateEvent = new StateEvent<State>(currState, e.getType(), e.getSubClass());
		State newState = stateEventController.getState(stateEvent);
		System.out.println("StackDivide curr BL = " + blState);
		if (blState == BLState.START) {
			System.out.println("StackDivide first");
			blState = BLState.ONGOING;
			LinkedList<Event> returnedEvents = funcByState(e);
			return returnedEvents;
		}
		
		if (newState != null) {
//			System.out.println("Changing states: " + currState + " -> " + newState);
			currState = newState;
			LinkedList<Event> returnedEvents = funcByState(e);
			return returnedEvents;
		}
		return null;
	}
	
	/**
	 * Switch case over the state we are currently in. 
	 * There is probably a much better way to do this
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	private LinkedList<Event> funcByState(Event e) {
		LinkedList<Event> resp = null;
		switch (currState)
		{
			case ASKFAVORITE:
				resp = stateAskFavorite(e);
				break;
			case MAKEDEAL:	
				resp = stateMakeDeal(e);
				break;
			case END:
				resp = stateEnd(e);
				break;

		}
		return resp;

	}
	
	private LinkedList<Event> stateAskFavorite(Event event){
		System.out.println("ResourceDivide ask pref");
		LinkedList<Event> resp = new LinkedList<Event>();
		Event askPref = new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.PREF_REQUEST,
				"I would like to divide the free resources as fairly as possible, can you please tell me what is your favorite resource?",
				(int) (1000 * game.getMultiplier()));
		resp.add(askPref);
		return resp;
	}
	
	private LinkedList<Event> stateEnd(Event e){
//		System.out.println("StackDivide stateEnd()");
		LinkedList<Event> resp = new LinkedList<Event>();
		
		// Stack divide offer was rejected by the player
		if (e.getSubClass() == Event.SubClass.OFFER_REJECT) {
			
			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_NEG,
					"Aww",(int) (1000 * game.getMultiplier())));

			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_EXPRESSION, "sad", 2000, (int) (100*game.getMultiplier())));	
			this.blState = BLState.FAILURE;
			
		// Stack divide offer was accepted by the player
		} else if (e.getSubClass() == Event.SubClass.OFFER_ACCEPT){
			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_POS,
					"Yay",(int) (1000 * game.getMultiplier())));

			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_EXPRESSION, "happy", 2000, (int) (100*game.getMultiplier())));	
			behavior.allocated = stateStartSuggestedOffer;
			this.blState = BLState.SUCCESS;

		// Stack divide offer was interrupted by the player by making a new offer
		} else {
			Event rudeTxt = new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_NEG,
					"How rude!",
					(int) (1000 * game.getMultiplier()));
//			Event rudeExpression = new Event(StaticData.playerId, Event.EventClass.SEND_EXPRESSION, "surprised", 2000, (int) (100*game.getMultiplier()));
			Event rudeExpression2 = new Event(StaticData.playerId, Event.EventClass.SEND_EXPRESSION, "angry", 2000, (int) (100*game.getMultiplier()));

//			resp.add(rudeExpression);
			resp.add(rudeExpression2);

			resp.add(rudeTxt);
			continueFlow=true; // Tell the main flow that we want for it to continue handling the event (probably with default bl)
			this.blState = BLState.FAILURE;

		}
		return resp;
	}
	
	private Event askFavor() {
		return new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.NONE,
				"We seem to both want the same resource, but there is an odd amount of it."
				+ " Would you mind giving me the larger part now and get the larger part next time?",
				(int) (1000 * game.getMultiplier()));
	}
	
	private Event returnFavor() {
		return new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.NONE,
				"We seem to both want the same resource, but there is an odd amount of it."
				+ " It's your turn to get the larger part, enjoy :)",
				(int) (1000 * game.getMultiplier()));
	}
	
	
	//Started an offer
		private LinkedList<Event> stateMakeDeal(Event event){
			LinkedList<Event> resp = new LinkedList<Event>();
			if (event.getPreference()!= null && !event.getPreference().isQuery()) {
				utils.addPref(event.getPreference());
				utils.reconcileContradictionsAll();
			}

			
			// Get the last allocated offer, and continue from there
			Offer offer = behavior.allocated;
			
			int agentFave = this.utils.getAgentFavoriteFreeResourceInOffer(offer);
			int playerFave = this.utils.getPlayerFavoriteFreeResourceInOffer(offer);
			int[][] offerMat = utils.offerToMatrix(offer);
			Offer resourceOffer;
			
			if (agentOwsAFavor) { 
				resourceOffer = resourceDivideMakeFavor(this.utils, offer, FavorState.PLAYER);
				agentOwsAFavor =! agentOwsAFavor;
			} else {
				resourceOffer = resourceDivide(this.utils, offer);
			}
			
			
			/*int itemsGivenToAgent = -1;
			int itemsGivenToPlayer = -1;

			
			// Are the stacks the same
			if (agentFave == playerFave) {
				
				//Is the number of items in the stack even?
				if (offerMat[utils.freeRow][agentFave] % 2 == 0) {
					itemsGivenToAgent = itemsGivenToPlayer = offerMat[utils.freeRow][agentFave] / 2;
				}
				else {
					// Does the player own the agent a favor, or no one owns anyone a favor
					if (agentOwsAFavor) {
						// Give the bigger part in exchange for a favor
						resp.add(returnFavor());
						itemsGivenToAgent = (int)(offerMat[utils.freeRow][agentFave] / 2);
						itemsGivenToPlayer = offerMat[utils.freeRow][agentFave] - itemsGivenToAgent;

					} else {
						// Ask for the bigger part in exchange for a favor
						resp.add(askFavor());
						itemsGivenToAgent = (int)(offerMat[utils.freeRow][agentFave] / 2) + 1;
						itemsGivenToPlayer = offerMat[utils.freeRow][agentFave] - itemsGivenToAgent;
					}
					
					
					agentOwsAFavor =! agentOwsAFavor;
				}
			}
			// Stacks are different
			// Distribute the min amount of free items in each stack
			else {
				itemsGivenToAgent = itemsGivenToPlayer = Math.min(offerMat[utils.freeRow][playerFave], offerMat[utils.freeRow][playerFave]);
			}*/
				
			///////////////////////////////////////////////////////////////
			/*offerMat[utils.adversaryRow][playerFave] += itemsGivenToPlayer;
			offerMat[utils.freeRow][playerFave] -= itemsGivenToPlayer;
			
			offerMat[utils.myRow][agentFave] += itemsGivenToAgent;
			offerMat[utils.freeRow][agentFave] -= itemsGivenToAgent;*/
			
			//Offer resourceOffer = utils.matrixToOffer(offerMat);
			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_OFFER, resourceOffer, (int) (700*game.getMultiplier())));
			stateStartSuggestedOffer = resourceOffer;
				
			
			return resp;
		}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * Divide one resource only to one side in the negotiation.
	 * @param util the AgentUtilExtension instance to achieve the preferences.
	 * @param offer the Offer that describes the current situation.
	 * @param state the 'identifier' of the negotiator to get a favor
	 * @return an Offer to suggest to the opponent.
	 */
	public Offer resourceDivideMakeFavor(AgentUtilsExtension util, Offer offer, FavorState favor){
		ArrayList<Integer> myPreference = util.getMyOrdering();
		int[][] table = util.offerToMatrix(offer);
		int[] myPreferredIndices = preferredItemsByLocation(myPreference);
		boolean isNotAbleToTrade = true;
		
		for(int index = 0; index < table[1].length; index++ ){
			isNotAbleToTrade = isNotAbleToTrade & (table[1][index] == 0);
		}
		
		if (!isNotAbleToTrade){
			switch (favor) {
			case PLAYER:
				// Giving to the opponent 1 resource
				for(int index = myPreferredIndices.length - 1; index>=0; index-- ){
					if (table[1][myPreferredIndices[index]] != 0){
						table[1][myPreferredIndices[index]]--;
						table[util.adversaryRow][myPreferredIndices[index]]++;
						break;
					}
				}
				
				break;
			case AGENT:
				// Taking 1 resource
				for(int index = 0; index<myPreferredIndices.length; index++ ){
					if (table[1][myPreferredIndices[index]] != 0){
						table[1][myPreferredIndices[index]]--;
						table[util.myRow][myPreferredIndices[index]]++;
						break;
					}
				}
	
				break;

			default:
				break;
			}
		}
		
		Offer o = new Offer(table[0].length);
		o.setOffer(createOfferFromMatrix(table));

		return o;
	}
	
	/**
	 * Divide one resource for each player.
	 * @param util the AgentUtilExtension instance to achieve the preferences.
	 * @param offer the Offer that describes the current situation.
	 * @return an Offer to suggest to the opponent.
	 */
	public Offer resourceDivide(AgentUtilsExtension util, Offer offer){
		ArrayList<Integer> myPreference = util.getMyOrdering();
		//ArrayList<Integer> playerPreference = util.getMinimaxOrdering(); 
		int[][] table = util.offerToMatrix(offer);
		int[] myPreferredIndices = preferredItemsByLocation(myPreference);
		//int[] playerPreferredIndices = preferredItemsByLocation(playerPreference);
		boolean isNotAbleToTrade = true;
		
		for(int index = 0; index < table[1].length; index++ ){
			isNotAbleToTrade = isNotAbleToTrade & (table[1][index] == 0);
		}
		
		if (!isNotAbleToTrade){	
			// Taking 1 resource
			for(int index = 0; index<myPreferredIndices.length; index++ ){
				if (table[1][myPreferredIndices[index]] != 0){
					table[1][myPreferredIndices[index]]--;
					table[util.myRow][myPreferredIndices[index]]++;
					break;
				}
			}
			
			// Giving to the opponent 1 resource
			for(int index = myPreferredIndices.length - 1; index>=0; index-- ){
				if (table[1][myPreferredIndices[index]] != 0){
					table[1][myPreferredIndices[index]]--;
					table[util.adversaryRow][myPreferredIndices[index]]++;
					break;
				}
			}
		}
		
		Offer o = new Offer(table[0].length);
		//o.setOffer(createOfferFromMatrix(table));
		o.setOffer(util.matrixToOffer(table));

		return o;
	}
	// {2,1,3} -> {1,0,2}
	public int[] preferredItemsByLocation(ArrayList<Integer> preference){
		int[] preferredItems = new int[preference.size()];
		
		for (int index = 0; index < preference.size(); index++){
			preferredItems[preference.get(index) - 1] = index;
			//preferredItems[tempPreference2[index] - 1] = index;
		}
		
		return preferredItems;
	}
	
	public int[] preferredItemsByLocationOld(ArrayList<Integer> preference){
		int[] tempPreference1 = new int[preference.size()];
		int[] tempPreference2 = new int[preference.size()];
		int[] preferredItems = new int[preference.size()];
		
		// Copy the preference to tempPreference1
		for (int index = 0; index < preference.size(); index++) {
			tempPreference1[index] = preference.get(index);
		}

		// Set value value of {3, 7, 2} would return {2, 1, 3},
		// with 1 being the highest
		for (int i = 0; i < tempPreference1.length; i++) {
			int maxIndex = 0;
			int maxValue = 0;
			for (int j = 0; j < tempPreference1.length; j++) {
				if (tempPreference1[j] > maxValue) {
					maxValue = tempPreference1[j];
					maxIndex = j;
				}
			}
			tempPreference1[maxIndex] = 0;
			tempPreference2[maxIndex] = i + 1;
		}
		
		for (int index = 0; index < preference.size(); index++){
			//preferredItems[preference.get(index) - 1] = index;
			preferredItems[tempPreference2[index] - 1] = index;
		}
		
		return preferredItems;
	}

	/**
	 * Creates offer object from matrix.
	 * @param table the matrix that contains the data of the resources.
	 * @return an Offer that created from the matrix.
	 */
	public Offer createOfferFromMatrix(int[][] table){
		Offer o = new Offer(table[0].length);
		int[] state = new int[3];
		for(int colIndex = 0; colIndex<table[0].length; colIndex++){
			for(int rowIndex = 0; rowIndex<3; rowIndex++){
				state[rowIndex] = table[rowIndex][colIndex];
			}
			
			o.setItem(colIndex,state);
		}
		
		return o;
	}

}
