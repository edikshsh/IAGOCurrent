package edu.usc.ict.iago.agent;

import java.util.HashMap;
import java.util.LinkedList;

import edu.usc.ict.iago.agent.BusinessLogic.BLState;
import edu.usc.ict.iago.agent.StackDivide.State;
import edu.usc.ict.iago.utils.Event;
import edu.usc.ict.iago.utils.Event.EventClass;
import edu.usc.ict.iago.utils.Event.SubClass;
import edu.usc.ict.iago.utils.GameSpec;
import edu.usc.ict.iago.utils.Offer;
import edu.usc.ict.iago.utils.ServletUtils;

public class RoundStart<State> extends BusinessLogic<State> {
	
	private IAGOCoreVH agentCore;
	private AgentUtilsExtension utils;
	private GameSpec game;
	private TestBehavior behavior;
	public static boolean agentOwsAFavor = false;
	private StateEventController<State> stateEventController; // Just here to let us use the StateEvent functions (can't be static because functions are generic)
	public State currState = State.START;
	
	enum State {
		 START,
	 }
	
	@Override
	public void reset() {
		super.reset();
		currState = State.START;
	}
	

	public RoundStart(AgentUtilsExtension utils, IAGOCoreVH agentCore, GameSpec game, TestBehavior behavior) {
		this.utils = utils;
		this.agentCore = agentCore;
		this.game = game;
		this.behavior = behavior;
		reset();
		this.stateEventController = new StateEventController<RoundStart.State>();
		stateEventController.massMachineStates(State.START, State.START, null, null, State.class);
	}
	
	/**
	 * Checks if the sent event is accepted in the current state. 
	 * Used to determine if we need to switch to a new algorithm
	 * @param e: The Event to be checked.
	 * @return True if the state machine accepts the event, false otherwise
	 */
	public boolean doesAcceptEvent(Event e) {
		boolean acceptEvent = stateEventController.doesAcceptEvent(e, currState); 
		return acceptEvent;
	}
	
	/**
	 * Starting point of the algorithm
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	public LinkedList<Event> stateStart(Event e){
		System.out.println("RoundStartAlgorithm stateStart()");
		blState = BLState.SUCCESS;
		return agentCore.gameStart(e);
	}
	
	/**
	 * Starting point of the algorithm
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	public LinkedList<Event> start(Event e){
		StateEvent<State> stateEvent = new StateEvent<State>(currState, e.getType(), e.getSubClass());
		State newState = stateEventController.getState(stateEvent);
		System.out.println("RoundStart curr BL = " + blState);
		if (blState == BLState.START) {
			System.out.println("RoundStart first");
			blState = BLState.ONGOING;
			LinkedList<Event> returnedEvents = funcByState(e);
			return returnedEvents;
		}
		
		if (newState != null) {
			currState = newState;
			LinkedList<Event> returnedEvents = funcByState(e);
			return returnedEvents;
		}
		return null;
	}
	
	/**
	 * Switch case over the state we are currently in. 
	 * There is probably a much better way to do this
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	private LinkedList<Event> funcByState(Event e) {
		LinkedList<Event> resp = null;
		switch (currState)
		{
			case START:
				resp = stateStart(e);
				break;
		}
		return resp;

	}
}
