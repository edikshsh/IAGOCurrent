package edu.usc.ict.iago.agent;

import java.util.HashMap;
import java.util.LinkedList;

import edu.usc.ict.iago.utils.Event;
import edu.usc.ict.iago.utils.Event.EventClass;
import edu.usc.ict.iago.utils.Event.SubClass;
import edu.usc.ict.iago.utils.GameSpec;
import edu.usc.ict.iago.utils.Offer;

public class StackDivide extends BusinessLogic {
	
	private IAGOCoreVH agentCore;
	private AgentUtilsExtension utils;
	private GameSpec game;
	private TestBehavior behavior;
	public static boolean agentOwsAFavor = false;
//	private HashMap<Tuple<State, String>, State> stateMachine;
//	private HashMap<StateEvent, State> stateMachine;
	private StateEventController<State> stateEventController; // Just here to let us use the StateEvent functions (can't be static because functions are generic)
	public State currState = State.START;
	private Offer stateStartSuggestedOffer = null;
	
	enum State {
		 START,
	 	 END
	 }
	
	//Creates many states, fills null parameters with all possible values
	private void massMachineStates(State start, State target, Event.EventClass ec, Event.SubClass esc) {
		State[] startingStates = new State[] {start};
		if (start == null) {
			startingStates = State.values();
		}
		
		Event.EventClass[] eventClasses = new Event.EventClass[] {ec};
		if (ec == null) {
			eventClasses = Event.EventClass.values();
		}
		
		Event.SubClass[] eventSubClasses = new Event.SubClass[] {esc};
		if (esc == null) {
			eventSubClasses = Event.SubClass.values();
		}
		
		for (State startingState: startingStates){
			for (Event.EventClass eventClass: eventClasses){
				for (Event.SubClass eventSubClass: eventSubClasses){
					// Skip unnecessary entries
					if (eventClass == Event.EventClass.SEND_MESSAGE || eventSubClass == Event.SubClass.NONE) {
						stateEventController.addState(startingState, target, eventClass, eventSubClass);
					}
				}
			}
		}
		
	}

	public StackDivide(AgentUtilsExtension utils, IAGOCoreVH agentCore, GameSpec game, TestBehavior behavior) {
		this.utils = utils;
		this.agentCore = agentCore;
		this.game = game;
		this.behavior = behavior;
		this.blState=BLState.ONGOING;
		this.stateEventController = new StateEventController<StackDivide.State>();
		massMachineStates(State.START, State.END, null, null);
		massMachineStates(State.END, State.START, Event.EventClass.SEND_MESSAGE, Event.SubClass.OFFER_ACCEPT);
		massMachineStates(State.END, State.START, Event.EventClass.SEND_MESSAGE, Event.SubClass.OFFER_REJECT);

//		stateEventController.addState(State.START, State.START, Event.EventClass.SEND_EXPRESSION, Event.SubClass.NONE);
//		stateEventController.addState(State.START, State.END, Event.EventClass.SEND_MESSAGE, null);
//		stateEventController.addState(State.END, State.START, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_POS);
	}
	
	/**
	 * Checks if the sent event is accepted in the current state. 
	 * Used to determine if we need to switch to a new algorithm
	 * @param e: The Event to be checked.
	 * @return True if the state machine accepts the event, false otherwise
	 */
	public boolean doesAcceptEvent(Event e) {
		return stateEventController.doesAcceptEvent(e, currState); 
	}
	
//	/**
//	 * Converts an event to StateEvents to be used as keys in the stateMachine. 
//	 * @param e: The Event used.
//	 * @return stateMachine keys to be searched
//	 */
//	private StateEvent<State>[] convertEventToTypes(Event e){
//		return stateEventController.convertEventToTypes(e, currState);
//	}
	
	/**
	 * Starting point of the algorithm
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	public LinkedList<Event> start(Event e){
//		System.out.println("StackDivide start()");
		StateEvent<State> stateEvent = new StateEvent<State>(currState, e.getType(), e.getSubClass());
		State newState = stateEventController.getState(stateEvent);

		
		if (newState != null) {
//			System.out.println("Changing states: " + currState + " -> " + newState);
			LinkedList<Event> returnedEvents = funcByState(e);
			currState = newState;
			return returnedEvents;
		}
		return null;
	}
	
	/**
	 * Switch case over the state we are currently in. 
	 * There is probably a much better way to do this
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	private LinkedList<Event> funcByState(Event e) {
		switch (currState)
		{
			case START:	
				return stateStart(e);
			case END:
				return stateEnd(e);
		}
		return null;

	}
	
	//Started an offer
	private LinkedList<Event> stateStart(Event event){
		LinkedList<Event> resp = new LinkedList<Event>();
		
		// Get the last allocated offer, and continue from there
		Offer offer = behavior.allocated;
		
		int agentFave = this.utils.getAgentFavoriteFreeResourceInOffer(offer);
		int playerFave = this.utils.getPlayerFavoriteFreeResourceInOffer(offer);
		int[][] offerMat = utils.offerToMatrix(offer);
		
		
		
		// Are the stacks the same
		if (agentFave == playerFave) {
			
			//Is the number of items in the stack even?
			if (offerMat[utils.freeRow][agentFave] % 2 == 0) {
				int itemsToDivide = offerMat[utils.freeRow][agentFave];
				offerMat[utils.adversaryRow][playerFave] += itemsToDivide /2;
				offerMat[utils.myRow][agentFave] += itemsToDivide /2;
			}
			else {
				// Does the player own the agent a favor, or no one owns anyone a favor
				if (agentOwsAFavor) {
					// Give the bigger part in exchange for a favor
					resp.add(returnFavor());

				} else {
					// Ask for the bigger part in exchange for a favor
					resp.add(askFavor());
				}
			}
		}
		// Stacks are different
		// Distribute the min amount of free items in each stack
		else {
			int itemsToTransfer = Math.min(offerMat[utils.freeRow][playerFave], offerMat[utils.freeRow][playerFave]);
			
			offerMat[utils.adversaryRow][playerFave] += itemsToTransfer;
			offerMat[utils.freeRow][playerFave] -= itemsToTransfer;
			
			offerMat[utils.myRow][agentFave] += itemsToTransfer;
			offerMat[utils.freeRow][agentFave] -= itemsToTransfer;
			
			Offer stackOffer = utils.matrixToOffer(offerMat);
			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_OFFER, stackOffer, (int) (700*game.getMultiplier())));
			stateStartSuggestedOffer = stackOffer;
			
		}
		return resp;
	}
	
	private LinkedList<Event> stateEnd(Event e){
//		System.out.println("StackDivide stateEnd()");
		LinkedList<Event> resp = new LinkedList<Event>();
		
		if (e.getSubClass() == Event.SubClass.OFFER_REJECT) {
			
			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_NEG,
					"Aww",(int) (1000 * game.getMultiplier())));

			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_EXPRESSION, "sad", 2000, (int) (100*game.getMultiplier())));	
			this.blState = BLState.FAILURE;
			
		} else {
			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_POS,
					"Yay",(int) (1000 * game.getMultiplier())));

			resp.add(new Event(StaticData.playerId, Event.EventClass.SEND_EXPRESSION, "happy", 2000, (int) (100*game.getMultiplier())));	
			behavior.allocated = stateStartSuggestedOffer;
			this.blState = BLState.SUCCESS;

		}
		return resp;
	}

	
	
	private Event askFavor() {
		return new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.FAVOR_REQUEST,
				"We seem to both want the same resource, but there is an odd amount of it."
				+ " Would you mind giving me the larger part now and get the larger part next time?",
				(int) (1000 * game.getMultiplier()));
	}
	
	private Event returnFavor() {
		return new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.FAVOR_ACCEPT,
				"We seem to both want the same resource, but there is an odd amount of it."
				+ " It's your turn to get the larger part, enjoy :)",
				(int) (1000 * game.getMultiplier()));
	}

}
