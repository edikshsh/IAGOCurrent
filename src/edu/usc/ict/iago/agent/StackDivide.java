package edu.usc.ict.iago.agent;

import java.util.HashMap;
import java.util.LinkedList;

import edu.usc.ict.iago.utils.Event;
import edu.usc.ict.iago.utils.GameSpec;
import edu.usc.ict.iago.utils.Offer;

public class StackDivide {
	
	private IAGOCoreVH agentCore;
	private AgentUtilsExtension utils;
	private GameSpec game;
	public boolean agentOwsAFavor = false;
//	private HashMap<Tuple<State, String>, State> stateMachine;
//	private HashMap<StateEvent, State> stateMachine;
	private StateEventController<State> stateEventController; // Just here to let us use the StateEvent functions (can't be static because functions are generic)
	public State currState = State.START;
	
	enum State {
		 START,
	 	 END
	 }

	public StackDivide(AgentUtilsExtension utils, IAGOCoreVH agentCore, GameSpec game) {
		this.utils = utils;
		this.agentCore = agentCore;
		this.game = game;
		this.stateEventController = new StateEventController<StackDivide.State>(); // Have to create the controller after the hashmap
		stateEventController.addState(State.START, State.START, Event.EventClass.SEND_EXPRESSION, Event.SubClass.NONE);
		stateEventController.addState(State.START, State.END, Event.EventClass.SEND_MESSAGE, null);
		stateEventController.addState(State.END, State.START, Event.EventClass.SEND_MESSAGE, Event.SubClass.GENERIC_POS);
	}
	
	/**
	 * Checks if the sent event is accepted in the current state. 
	 * Used to determine if we need to switch to a new algorithm
	 * @param e: The Event to be checked.
	 * @return True if the state machine accepts the event, false otherwise
	 */
	public boolean doesAcceptEvent(Event e) {
		return stateEventController.doesAcceptEvent(e, currState); 
	}
	
	/**
	 * Converts an event to StateEvents to be used as keys in the stateMachine. 
	 * @param e: The Event used.
	 * @return stateMachine keys to be searched
	 */
	private StateEvent<State>[] convertEventToTypes(Event e){
		return stateEventController.convertEventToTypes(e, currState);
	}
	
	/**
	 * Starting point of the algorithm
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	public LinkedList<Event> start(Event e){
//		System.out.println("StackDivide start()");
		State newState = null;
		StateEvent<State>[] eventTypes = convertEventToTypes(e);
		for (StateEvent<State> eventType : eventTypes) {
//			System.out.println("Checking event " + eventType);
			if ((newState = stateEventController.getState(eventType)) != null) {
//				System.out.println("Event " + eventType + " is legal");
				break;
			}
		}
		if (newState != null) {
//			System.out.println("Changing states: " + currState + " -> " + newState);
			currState = newState;
			return funcByState(e);
		}
		return null;
	}
	
	/**
	 * Switch case over the state we are currently in. 
	 * There is probably a much better way to do this
	 * @param e: The Event received from the parent flow.
	 * @return list of events generated by the algorithm (can be null)
	 */
	private LinkedList<Event> funcByState(Event e) {
		switch (currState)
		{
			case START:	
				return stateStart(e);
			case END:
				return stateEnd(e);
		}
		return null;

	}
	
	private LinkedList<Event> stateStart(Event e){
//		System.out.println("StackDivide stateStart()");
		LinkedList<Event> resp = new LinkedList<Event>();

		return resp;
	}
	
	private LinkedList<Event> stateEnd(Event e){
//		System.out.println("StackDivide stateEnd()");
		LinkedList<Event> resp = new LinkedList<Event>();

		return resp;
	}
	
	// Trash currently, need to divide into states
	public LinkedList<Event> mainAlgorithm(Event event) {
		
		
		LinkedList<Event> resp = new LinkedList<Event>();
		// Event might be something else, not an offer
		Offer offer = event.getOffer();
		
		int agentFave = this.utils.getAgentFavoriteFreeResourceInOffer(offer);
		int playerFave = this.utils.getPlayerFavoriteFreeResourceInOffer(offer);
		int[][] offerMat = utils.offerToMatrix(offer);
		
		
		
		// Are the stacks the same
		if (agentFave == playerFave) {
			
			//Is the number of items in the stack even?
			if (offerMat[utils.freeRow][agentFave] % 2 == 0) {
				int itemsToDivide = offerMat[utils.freeRow][agentFave];
				offerMat[utils.adversaryRow][playerFave] += itemsToDivide /2;
				offerMat[utils.myRow][agentFave] += itemsToDivide /2;
			}
			else {
				// Does the player own the agent a favor, or no one owns anyone a favor
				if (utils.getLedger() >= 0) {
					
					// Ask for the bigger part in exchange for a favor
					utils.modifyVerbalLedger(-1);
					resp.add(askFavor());
				} else {
					
					// Give the bigger part in exchange for a favor
					utils.modifyVerbalLedger(1);
					resp.add(returnFavor());
				}
			}
		}
		// Stacks are different
		// Distribute the min amount of free items in each stack
		else {
			int itemsToTransfer = Math.min(offerMat[utils.freeRow][playerFave], offerMat[utils.freeRow][playerFave]);
			
			offerMat[utils.adversaryRow][playerFave] += itemsToTransfer;
			offerMat[utils.freeRow][playerFave] -= itemsToTransfer;
			
			offerMat[utils.myRow][agentFave] += itemsToTransfer;
			offerMat[utils.freeRow][agentFave] -= itemsToTransfer;
			
			Offer stackOffer = utils.matrixToOffer(offerMat);
			
		}
		return resp;
	}

	
	
	public Event askFavor() {
		return new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.FAVOR_REQUEST,
				"We seem to both want the same resource, but there is an odd amount of it."
				+ " Would you mind giving me the larger part now and get the larger part next time?",
				(int) (1000 * game.getMultiplier()));
	}
	
	public Event returnFavor() {
		return new Event(StaticData.playerId, Event.EventClass.SEND_MESSAGE, Event.SubClass.FAVOR_ACCEPT,
				"We seem to both want the same resource, but there is an odd amount of it."
				+ " It's your turn to get the larger part, enjoy :)",
				(int) (1000 * game.getMultiplier()));
	}

}
